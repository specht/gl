#!/usr/bin/env ruby

require 'active_support/inflector'
require 'fileutils'
require 'json'
require 'open3'
require 'pathname'
require 'stringio'
require 'tempfile'
require 'uri'
require 'yaml'

# try to load the paint gem for colored text output and provide a fallback it's not available
begin
    require 'paint'
rescue LoadError
    class Paint
        def self.[](s, *args)
            s
        end
    end
end

class GitLabIssuesConnectedToGit
    def initialize
        if ENV['COMP_LINE']
            handle_bash_completion
        end
        setup
    end

    def handle_bash_completion
        parts = ENV['COMP_LINE'].split(' ')
        parts << '' if ENV['COMP_LINE'][-1] == ' '
        parts.shift()
        if parts.size == 1
            # only one argument has been (partially) typed, auto-complete it
            ['init', 'update', 'list', 'show', 'start', 'commit', 'labels'].each do |w|
                if w.index(parts.last) == 0
                    puts w
                end
            end
        else
            # auto-completion invoked on the second argument
            if ['start', 'commit', 'show'].include?(parts.first)
                allow_closed = true
                allow_closed = false if ['start', 'commit'].include?(parts.first)
                setup
                update_if_necessary
                @issues.each_pair do |id, issue|
                    next if (!allow_closed) && @issues[id]['state'] != 'opened'
                    slug = issue['title'].parameterize
                    branch_name = "#{id}-#{slug}"
                    search_terms = parts[1, parts.size - 1]
                    left_over_search_terms = search_terms.reject do |term|
                        term = term.downcase
                        slug.split('-').any? do |x|
                            x.downcase[0, term.size] == term
                        end || slug[0, term.size] == term
                    end
                    if left_over_search_terms.empty?
                        puts branch_name
                    else
                        if branch_name.index(search_terms.first.downcase) == 0
                            if branch_name != search_terms.first
                                puts branch_name
                            end
                        end
                    end
                end
            elsif ['list'].include?(parts.first)
                setup
                update_if_necessary
                collect_labels().each do |label|
                    slug = label.parameterize
                    search_terms = parts[1, parts.size - 1]
                    left_over_search_terms = search_terms.reject do |term|
                        term = term.downcase
                        slug.split('-').any? do |x|
                            x.downcase[0, term.size] == term
                        end || slug[0, term.size] == term
                    end
                    if left_over_search_terms.empty?
                        puts slug
                    else
                        if slug.index(search_terms.first.downcase) == 0
                            if slug != search_terms.first
                                puts slug
                            end
                        end
                    end
                end
            end
        end
        exit(0)
    end

    def warning(&block)
        STDERR.puts Paint['-' * 75, :red]
        io = StringIO.new
        yield(io)
        STDERR.puts Paint[io.string.strip, :red]
        STDERR.puts Paint['-' * 75, :red]
        STDERR.puts
    end

    def error(message)
        STDERR.puts "Error: #{message}"
        exit(1)
    end

    def assert_not_world_readable(path)
        if File.stat(path).world_readable?
            warning do |io|
                io.puts "WARNING: #{path} is world readable."
                io.puts "You should fix this with something like:"
                io.puts "$ chmod 600 #{path}"
            end
        end
    end

    def assert_ignored_by_git(path)
        `git check-ignore -q "#{path}"`
        unless $? == 0
            warning do |io|
                io.puts "WARNING: #{path} is not ignored by Git."
                io.puts "You should fix this with something like:"
                relative_path = Pathname.new(path).relative_path_from(Pathname.new(File::join(@project_root, '..'))).to_s
                gitignore_path = Pathname.new(File.join(@project_root, '..', '.gitignore')).relative_path_from(Pathname.new($pwd)).to_s
                io.puts "$ echo '#{relative_path}' >> #{gitignore_path}"
                io.puts "$ git add #{gitignore_path} && git commit -m '.gitignore update for gl'"
            end
        end
    end

    def setup
        @project_root = Dir::pwd
        while !File::directory?(File::join(@project_root, '.git'))
            @project_root = File.expand_path('..', @project_root)
            if @project_root == '/'
                error('Not a git repository.')
            end
        end

        Dir::chdir(@project_root)

        @project_root = File::join(@project_root, '.gl')

        @hook_path = File::join(@project_root, '..', '.git', 'hooks', 'prepare-commit-msg')

        unless File::exist?(@hook_path)
            unless ARGV.first == 'init'
                STDERR.puts "Error: project not initialized. Please run 'gl init'."
                STDERR.puts "If you're just installing gl on your machine, you might want to create the following symlink:"
                STDERR.puts "$ sudo ln -s #{File::expand_path(__FILE__)} /usr/local/bin/gl"
                exit(1)
            end
        end

        @config_path = File::join(@project_root, 'config.yaml')
        if File::exist?(@config_path)
            @config = YAML::load(File::read(@config_path))
            @project_uri = @config['project_uri']
        else
            git_remote = `git remote get-url origin`.strip
            remote_uri = git_remote.sub('git@', 'https://').sub(':', '/').sub('.git', '')
            @project_uri_path = File::join(@project_root, 'project_uri')
            STDERR.puts "Error: no project configuration defined (#{@config_path} not found)."
            STDERR.puts "This only has to be done once and you should only see this if you're the project maintainer."
            STDERR.puts "Go to the project's GitLab page and enter the URL shown in your browser's address bar."
            STDERR.puts
            STDERR.print "Project URL [#{remote_uri}] "
            uri = STDIN.readline.strip
            if uri.empty?
                uri = remote_uri
            end
            STDERR.puts
            u = URI::parse(uri)
            @project_uri = "#{u.scheme}://#{u.host}/api/v4/projects/#{u.path.split('/').select { |x| !x.empty? }.join('%2f')}"
            STDERR.puts "I've derived the following project URI from what you've just entered:"
            STDERR.puts @project_uri
            STDERR.puts
            STDERR.puts "If you need to correct this, please edit .gl/config.yaml - this is where the project URI is stored, along with other settings"
            STDERR.puts "Please add and commit .gl/config.yaml so that other developers won't have to repeat this step:"
            STDERR.puts
            STDERR.puts "$ git add #{@config_path}"
            STDERR.puts "$ git commit -m 'added gl configuration'"

            FileUtils::mkpath(File::dirname(@config_path))

            @config = {'project_uri' => @project_uri, 'max_commit_message_header_length' => nil}

            File::open(@config_path, 'w') do |f|
                f.puts(@config.to_yaml)
            end
        end

        @private_token_path_repository = File::join(@project_root, 'private_token')
        @private_token_path_user = File::join(Dir.home, '.gl_private_token')
        if File.exist?(@private_token_path_repository)
            assert_not_world_readable(@private_token_path_repository)
            assert_ignored_by_git(@private_token_path_repository)
            @token = File::read(@private_token_path_repository).strip
        else
            if File.exist?(@private_token_path_user)
                assert_not_world_readable(@private_token_path_user)
                @token = File::read(@private_token_path_user).strip
            else
                STDERR.puts "Error: no private token stored for GitLab API access."
                STDERR.puts "Please log into GitLab and create a Personal Access Token:"
                u = URI::parse(@project_uri)
                STDERR.puts
                STDERR.puts "#{u.scheme}://#{u.host}/profile/personal_access_tokens"
                STDERR.puts
                STDERR.puts "Make sure you check the 'api' checkbox!"
                STDERR.puts "When you're done, paste the token here:"
                STDERR.puts
                STDERR.print "Token: "
                @token = STDIN.readline.strip
                FileUtils::mkpath(File::dirname(@private_token_path_repository))
                File::open(@private_token_path_repository, 'w') do |f|
                    f.write(@token)
                end
                # set file permissions (it's a private token and as such it should be private)
                File.chmod(0600, @private_token_path_repository)
                assert_ignored_by_git(@private_token_path_repository)
            end
        end
        @issues_path = File::join(@project_root, 'issues.yaml')
        assert_ignored_by_git(@issues_path)

        update_if_necessary
        @issues = YAML::load(File::read(@issues_path))
    end

    def current_issue()
        id = `git branch`.split("\n").select do |x|
            x.strip[0, 1] == '*'
        end.first.sub('*', '').strip.split('-').first
        if id =~ /^\d+$/
            id.to_i
        else
            nil
        end
    end

    def init()
        FileUtils::mkpath(File::dirname(@hook_path))
        File::open(@hook_path, 'w') do |f|
            f.write DATA.read
        end
        system("chmod +x \'#{@hook_path}\'")
        STDERR.puts "Successfully installed Git prepare-commit-msg hook."
    end

    def curl_gitlab(url)
        page = 1
        data = nil
        loop do
            header_path = Dir::Tmpname.create('gl-curl-response-headers') {}
            command = "curl -D \"#{header_path}\" -sS --header 'PRIVATE-TOKEN: #{@token}' '#{@project_uri}/#{url}/?per_page=100&page=#{page}'"
            stdin, stdout, stderr, thread = Open3.popen3(command)
            stdin.close
            exit_code = thread.value.exitstatus
            if exit_code == 0
                body = stdout.read
                new_data = JSON::parse(body)
                if data.nil?
                    data = new_data
                else
                    data += new_data
                end
            else
                STDERR.print "\r"
                STDERR.puts stderr.read
                exit(1)
            end
            stdout.close
            stderr.close
            headers = {}
            File::read(header_path).split("\n").each do |x|
                colon_index = x.index(':')
                next unless colon_index
                key = x[0, colon_index].strip
                value = x[colon_index + 1, x.size].strip
                headers[key] = value
            end
            if headers['X-Page'] && headers['X-Page'].to_i < headers['X-Total-Pages'].to_i
                page += 1
            else
                break
            end
        end
        data
    end

    def update()
        thread = Thread.new do
            loop do
                ['|', '/', '-', '\\'].each do |c|
                    STDERR.print "\r#{c}"
                    sleep 0.1
                end
            end
        end
        thread.run

        issues = {}
        curl_gitlab('issues').each do |entry|
            issues[entry['iid']] = entry
        end
        issues_by_status = {}
        issues.values.each do |issue|
            issues_by_status[issue['state']] ||= 0
            issues_by_status[issue['state']] += 1
        end

        thread.kill
        STDERR.print "\r"

        STDERR.puts "Fetched #{issues.size} issues (#{issues_by_status.keys.sort.reverse.map { |x| "#{issues_by_status[x]} #{x}" }.join(', ')})."
        File::open(@issues_path, 'w') do |f|
            f.write issues.to_yaml
        end
        @issues = issues

        # TODO: update branch names
    end

    def update_if_necessary
        update unless File::exist?(@issues_path)
    end

    def list(label = nil)
        id_width = @issues.keys.max.to_s.size
        @issues.keys.sort.each do |id|
            if @issues[id]['state'] == 'opened'
                unless label.nil?
                    next unless @issues[id]['labels'].map { |x| x.parameterize }.include?(label)
                end
#                 color = :green
#                 if @issues[id]['labels'].include?('Recurring')
#                     color = :yellow
#                 end
                print "[##{id}]#{' ' * (id_width - id.to_s.size)} #{@issues[id]['title']}"
                puts
#                 puts "#{' ' * id_width}    #{@issues[id]['labels'].sort.join(' / ')}"
            end
        end
    end

    def show(id)
        id = current_issue if id.nil?
        if id.nil?
            STDERR.puts "Usage: gl show <issue id>"
            exit(1)
        end
        update_if_necessary
        if @issues.include?(id)
            issue = @issues[id]
            l = "[##{id}] #{issue['title']}"
            puts '-' * 75
            puts l
            puts '-' * 75
            puts "Labels:   #{issue['labels'].empty? ? '(none)' : issue['labels'].join(', ')}"
            puts "State:    #{issue['state']}"
            puts "Created:  #{issue['created_at'][0, 10]}"
            if issue['assignee']
                puts "Assigned: #{issue['assignee']['name']}"
            end
            if issue['due_date']
                duration = (DateTime.parse(issue['due_date']) - DateTime.now).to_f.ceil
                if duration == 0
                    duration = "today"
                elsif duration == 1
                    duration = "tomorrow"
                elsif duration < 7
                    duration = "#{duration} days from now"
                else
                    duration = "#{duration / 7} weeks from now"
                end
                puts "Due date: #{issue['due_date'][0, 10]} (#{duration})"
            end
#             puts "Updated:  #{issue['updated_at'][0, 10]}"
            puts "URL:      #{issue['web_url']}"
            puts
            puts issue['description']
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end

    def start(id)
        if id.nil?
            STDERR.puts "Usage: gl start <issue id>"
            exit(1)
        end
        update_if_necessary
        if @issues.include?(id)
            branch_name = "#{id}-#{@issues[id]['title'].parameterize}"
            system("git branch #{branch_name} 2> /dev/null")
            system("git checkout #{branch_name}")
            if $?.success?
                merged_branches = `git branch --merged #{branch_name}`.split.map do |x|
                    x.strip
                end
                if merged_branches.include?('master')
                    puts "Branch is up-to-date with master."
                else
                    puts "Branch is not up-to-date with master, please run:"
                    puts "$ git merge master"
                end
            end
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end

    def commit(id, args)
        id = current_issue if id.nil?
        if id.nil?
            STDERR.puts "Usage: gl commit <issue id> [further options passed to git]"
            exit(1)
        end
        update_if_necessary
        if @issues.include?(id)
            system("GL_COMMIT_USING_ISSUE=#{id} git commit #{(args || []).join(' ')}")
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end

    def commit_message()
        update_if_necessary
        id = nil
        if ENV.include?('GL_COMMIT_USING_ISSUE')
            id ||= ENV['GL_COMMIT_USING_ISSUE'].to_i
        end
        id ||= current_issue
        if id
            if @issues.include?(id)
                line = "[##{id}] #{@issues[id]['title']}".strip
                max_length = @config['max_commit_message_header_length']
                if max_length && line.size > max_length - 3
                    line = line[0, max_length - 3] + '...'
                end
                puts line
            else
                puts "# Error: no issue found with id #{id}."
            end
        else
            puts "# You're not in a topic branch. :-("
        end
    end

    def collect_labels()
        if @all_labels.nil?
            @all_labels = Set.new()
            @issues.values.each do |issue|
                @all_labels |= Set.new(issue['labels'])
            end
        end
        @all_labels
    end

    def labels()
        collect_labels().sort.each do |label|
            puts label
        end
    end

    def run
        args = ARGV
        command = args.first
        case command
        when 'init'
            init
        when 'update'
            update
        when 'list'
            list(args[1])
        when 'start'
            start(args[1].nil? ? nil : args[1].to_i)
        when 'commit'
            commit(args[1].nil? ? nil : args[1].to_i, args[2, args.size - 2])
        when 'show'
            show(args[1].nil? ? nil : args[1].to_i)
        when 'commit-message'
            commit_message
        when 'labels'
            labels
        else
            puts 'Usage: gl <init|update|list|start|commit|show|labels>'
            puts '  init           - set up git hook'
            puts '  update         - fetch issues from GitLab server'
            puts '  list [<label>] - list all open issues (with label if specified)'
            puts '  start <id>     - start a topic branch for the given issue'
            puts '  commit <id>    - commit for an issue from any branch'
            puts '  show <id>      - show issue'
            puts '  labels         - show labels'
        end
    end
end

$pwd = Dir.pwd
begin
    script = GitLabIssuesConnectedToGit.new
    script.run
ensure
    Dir.chdir($pwd)
end

__END__
#!/usr/bin/env ruby

template = File::read(ARGV.first)
unless template.index('Merge branch') == 0
    message = `gl commit-message`

    File::open(ARGV.first, 'w') do |f|
        f.puts message
        f.write(template)
    end
end
