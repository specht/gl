#!/usr/bin/env ruby

require 'fileutils'
require 'json'
require 'yaml'
require 'uri'

class GitLabIssuesConnectedToGit
    def setup(interactive)
        @project_root = Dir::pwd
        while !File::directory?(File::join(@project_root, '.git'))
            @project_root = File.expand_path('..', @project_root)
            if @project_root == '/'
                STDERR.puts "Error: Not a git repository."
                exit(1)
            end
        end
        
        Dir::chdir(@project_root)

        @project_root = File::join(@project_root, '.gl')

        @project_uri_path = File::join(@project_root, 'project_uri')
        @private_token_path = File::join(@project_root, 'private_token')
        @issues_path = File::join(@project_root, 'issues.yaml')
        @hook_path = File::join(@project_root, '..', '.git', 'hooks', 'prepare-commit-msg')
        
        unless File::exists?(@hook_path)
            unless ARGV.first == 'init'
                STDERR.puts "Error: project not initialized. Please run 'gl init'."
                STDERR.puts "If you're just installing gl on your machine, you might want to create the following symlink:"
                STDERR.puts "$ sudo ln -s #{File::expand_path(__FILE__)} /usr/local/bin/gl"
                exit(1)
            end
        end

        if File::exists?(@project_uri_path)
            @project_uri = File::read(@project_uri_path).strip
        else
            STDERR.puts "Error: no project URI defined."
            STDERR.puts "This only has to be done once and you should only see this if you're the project maintainer."
            STDERR.puts "Go to the project page and enter the URL shown in your browser's address bar."
            STDERR.puts
            STDERR.print "Project URL: "
            uri = STDIN.readline.strip
            STDERR.puts
            u = URI::parse(uri)
            @project_uri = "#{u.scheme}://#{u.host}/api/v4/projects/#{u.path.split('/').select { |x| !x.empty? }.join('%2f')}"
            STDERR.puts "I've derived the following project URI from what you've just entered:"
            STDERR.puts @project_uri
            STDERR.puts
            STDERR.puts "If you need to correct this, please edit .gl/project_uri - this is where the project URI is stored."
            STDERR.puts "Please add and commit .gl/project_uri so that other developers won't have to repeat this step:"
            STDERR.puts
            STDERR.puts "$ git add .gl/project_uri"
            STDERR.puts "$ git commit -m 'added .gl/project_uri'"
            
            FileUtils::mkpath(File::dirname(@project_uri_path))
            File::open(@project_uri_path, 'w') do |f|
                f.write(@project_uri)
            end
        end
        if File::exists?(@private_token_path)
            @token = File::read(@private_token_path).strip
        else
            STDERR.puts "Error: no private token stored for GitLab API access."
            STDERR.puts "Please log into GitLab and create a Personal Access Token:"
            u = URI::parse(@project_uri)
            STDERR.puts
            STDERR.puts "#{u.scheme}://#{u.host}/profile/personal_access_tokens"
            STDERR.puts
            STDERR.puts "Make sure you check the 'api' checkbox!"
            STDERR.puts "When you're done, paste the token here:"
            STDERR.puts
            STDERR.print "Token: "
            @token = STDIN.readline.strip
            FileUtils::mkpath(File::dirname(@private_token_path))
            File::open(@private_token_path, 'w') do |f|
                f.write(@token)
            end
        end
    end
    
    def initialize()
        if ENV['COMP_LINE']
            parts = ENV['COMP_LINE'].split(' ')
            parts << '' if ENV['COMP_LINE'][-1] == ' '
            parts.shift()
            if parts.size == 1
                ['init', 'update', 'list', 'show', 'branch'].each do |w|
                    if w.index(parts.last) == 0
                        puts w
                    end
                end
            elsif ['branch', 'show'].include?(parts.first)
                setup(false)
                update() unless File::exists?(@issues_path)
                issues = YAML::load(File::read(@issues_path))
                issues.each_pair do |id, issue|
                    branch_name = "#{id}-#{issue[:slug]}"
                    search_terms = parts[1, parts.size - 1]
                    left_over_search_terms = search_terms.reject do |term|
                        term = term.downcase
                        issue[:slug].split('-').any? do |x|
                            x.downcase[0, term.size] == term
                        end
                    end
                    if left_over_search_terms.empty?
                        puts branch_name
                    else
                        if branch_name.index(search_terms.first.downcase) == 0
                            if branch_name != search_terms.first
                                puts branch_name
                            end
                        end
                    end
                end
            end
            exit(0)
        end
        
        setup(true)
    end
    
    def init()
        FileUtils::mkpath(File::dirname(@hook_path))
        File::open(@hook_path, 'w') do |f|
            f.write <<~eos
                #!/usr/bin/env ruby

                template = File::read(ARGV.first)
                unless  template.index('Merge branch') == 0
                    message = `gl commit-message`

                    File::open(ARGV.first, 'w') do |f|
                        f.puts message
                        f.write(template)
                    end
                end
            eos
        end
        system("chmod +x \'#{@hook_path}\'")
        STDERR.puts "Successfully installed Git prepare-commit-msg hook."
    end
    
    def update()
        command = "curl -s --header 'PRIVATE-TOKEN: #{@token}' #{@project_uri}/issues"
        thread = Thread.new do
            while true do
                ['|', '/', '-', '\\'].each do |c|
                    STDERR.print "\r#{c}"
                    sleep 0.1
                end
            end
        end
        thread.run
        data = JSON.parse(`#{command}`)
        issues = {}
        data.each do |entry|
            issues[entry['iid']] = {
                :entry => entry,
                :slug => entry['title'].downcase.gsub(/[^a-zA-Z0-9]+/, ' ').strip.gsub(' ', '-')
            }
        end
        thread.kill
        STDERR.puts "\rFetched #{issues.size} issues."
        File::open(@issues_path, 'w') do |f|
            f.write issues.to_yaml
        end
        
        # TODO: update branch names
        
        branches = `git branch`
    end
    
    def list()
        update() unless File::exists?(@issues_path)
        issues = YAML::load(File::read(@issues_path))
        id_width = issues.keys.max.to_s.size
        issues.keys.sort.each do |id|
            if issues[id][:entry]['state'] == 'opened'
                print sprintf("%-#{id_width}s", "[#{id}]")
                print ' '
                print sprintf('%s', issues[id][:entry]['title'])
                puts
            end
        end
    end
    
    def show(id)
        if id.nil?
            STDERR.puts "Usage: gl show <issue id>"
            exit(1)
        end
        update() unless File::exists?(@issues_path)
        issues = YAML::load(File::read(@issues_path))
        if issues.include?(id)
            issue = issues[id][:entry]
            l = "[#{id}] #{issue['title']}"
            puts '-' * 75
            puts l
            puts '-' * 75
            puts "Labels:  #{issue['labels'].join(', ')}"
            puts "State:   #{issue['state']}"
            puts "Created: #{issue['created_at'][0, 10]}"
            puts "Updated: #{issue['updated_at'][0, 10]}"
            puts "URL:     #{issue['web_url']}"
            puts
            puts issue['description']
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end
    
    def branch(id)
        if id.nil?
            STDERR.puts "Usage: gl branch <issue id>"
            exit(1)
        end
        update() unless File::exists?(@issues_path)
        issues = YAML::load(File::read(@issues_path))
        if issues.include?(id)
            branch_name = "#{id}-#{issues[id][:slug]}"
            system("git branch #{branch_name} 2> /dev/null")
            system("git checkout #{branch_name}")
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end

    def commit_message()
        update() unless File::exists?(@issues_path)
        id = `git branch`.split("\n").select do |x|
            x.strip[0, 1] == '*'
        end.first.sub('*', '').strip.split('-').first.to_i
        issues = YAML::load(File::read(@issues_path))
        if issues.include?(id)
            puts "[##{id}] #{issues[id][:entry]['title']}"
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end
            
    def run()
        args = ARGV
        command = args.first
        case command
        when 'init'
            init()
        when 'update'
            update()
        when 'list'
            list()
        when 'branch'
            branch(args[1].nil? ? nil : args[1].to_i)
        when 'show'
            show(args[1].nil? ? nil : args[1].to_i)
        when 'commit-message'
            commit_message()
        else
            puts "Usage: gl <init|update|list|branch>"
            puts "  init        - set up git hook"
            puts "  update      - fetch issues from GitLab server"
            puts "  list        - list all open issues"
            puts "  branch <id> - checkout a topic branch for the given issue"
            puts "  show <id>   - show issue"
        end
    end
end

pwd = Dir::pwd
begin
    script = GitLabIssuesConnectedToGit.new
    script.run
ensure
    Dir::chdir(pwd)
end
