#!/usr/bin/env ruby

require 'active_support/inflector'
require 'fileutils'
require 'json'
require 'open3'
require 'pathname'
require 'stringio'
require 'tempfile'
require 'uri'
require 'yaml'

$: << File.dirname(File.realpath($0))
require 'include/pager'
require 'include/cli-dispatcher'

# try to load the paint gem for colored text output and provide a fallback it's not available
begin
    require 'paint'
    Paint.mode = 256
rescue LoadError
    class Paint
        def self.[](s, *args)
            s
        end
    end
end

class GitLabIssuesConnectedToGit
    def initialize
        # first try editor configured by Git
        @editor = `git config core.editor`
        @editor = nil if @editor.empty?
        # if that failed, check EDITOR environment variable
        @editor ||= ENV['EDITOR']
        # if that failed as well, fall back to nano
        @editor ||= 'nano'
        
        CliDispatcher::launch do |ac|
            ac.option('help') do |ac|
                ['new', 'list', 'show', 'edit', 'start', 'close', 
                 'reopen', 'locate', 'commit', 'update', 'labels',
                 'search'].each do |x|
                    ac.option(x)
                end
                ac.handler { |args| run_pager(); show_help(args) }
            end
            
            # Issue commands
            
            ac.option('new', nil, true) do |ac, collected_parts|
                setup
                define_autocomplete_labels(ac, false, false, Set.new(collected_parts[1, collected_parts.size - 1]))
                ac.handler { |args| new_issue(args) }
            end
            
            ac.option('list', nil, true) do |ac, collected_parts|
                setup
                ac.option('--all')
                ac.option('--closed')
#                 define_autocomplete_labels(ac, false, false, Set.new(collected_parts[1, collected_parts.size - 1]))
                ac.handler { |args| run_pager(); list(args) }
            end
            
            def current_issue_or_from_args(args)
                issue = nil
                if args.first
                    issue = args.first
                else
                    issue = `git rev-parse --abbrev-ref HEAD`.strip[0, 6]
                    issue = nil unless issue =~ /^[a-z]{2}\d{4}$/
                end
                unless issue
                    puts "Error: No issue specified (and also not currently in an issue branch)."
                    exit(1)
                end
                return issue
            end
            
            ac.option('show') do |ac|
                define_autocomplete_issues(ac)
                ac.handler do |args|
                    issue = current_issue_or_from_args(args)
                    run_pager()
                    show(issue)
                end
            end
                
            ac.option('oneline') do |ac|
                define_autocomplete_issues(ac)
                ac.handler do |args| 
                    issue = current_issue_or_from_args(args)
                    oneline(issue)
                end
            end
                
            ac.option('edit') do |ac|
                define_autocomplete_issues(ac)
                ac.handler do |args|
                    issue = current_issue_or_from_args(args)
                    edit_object(issue)
                end
            end
                
            ac.option('start') do |ac|
                define_autocomplete_issues(ac)
                ac.handler { |args| start_working_on_issue(args.first) }
            end
                
            ac.option('rm') do |ac|
                define_autocomplete_issues(ac)
                ac.handler { |args| rm_issue(args.first) }
            end
                
            ac.option('restore') do |ac|
                current_issue_ids = all_issue_ids(false)
                define_autocomplete_issues(ac, true, false, Set.new(current_issue_ids))
                ac.handler { |args| restore_issue(args.first) }
            end
                
            ac.option('commit') do |ac|
                define_autocomplete_issues(ac)
                ac.handler { |args| commit_using_issue(args.first, args[1, args.size - 1]) }
            end

            # Miscellaneous commands
            
            ac.option('update') do |ac|
                setup
                ac.handler { |args| update(); }
            end
            
            ac.option('search') do |ac|
                define_autocomplete_keywords(ac)
                ac.handler { |args| run_pager(); search(args) }
            end
                
            ac.option('log') do |ac|
                ac.handler { |args| run_pager(); log() }
            end
                
            ac.option('locate') do |ac|
                define_autocomplete_issues(ac)
                ac.handler do |args|
                    issue = current_issue_or_from_args(args)
                    run_pager()
                    locate_issue(issue)
                end
            end

            ac.option('pull') do |ac|
                ac.handler { |args| pull() }
            end
                
            ac.option('push') do |ac|
                ac.handler { |args| push() }
            end

            ac.option('visualize') do |ac|
                ac.handler { |args| visualize() }
            end
        end
        puts "Unknown command: #{ARGV.first}. Try 'gl help' for a list of possible commands."
    end

    # auto-completion helper: define categories and issues with slugs and slug parts
    # If recursive == false, only define current objects
    # If recursive == true, also walk back in history and define removed objects
    # Use include to specify IDs to use (instead of using all_ids)
    # Use exclude to specify completions that should be excluded
    def define_autocomplete_object(type, ac, recursive = false, inception = false, exclude = Set.new(), include = nil, &block)
        use_ids = include
        use_ids ||= all_ids(recursive, type)
        use_ids.each do |id|
            object = load_object(id)
            next if exclude.include?(object[:slug]) || exclude.include?(object[:id])
            ac.option(object[:slug], nil, inception, &block)
            ac.option(object[:slug], object[:slug], inception, &block)
            object[:slug_pieces].each do |p|
                ac.option(p, object[:slug], inception, &block)
            end
        end
    end
    
    def define_autocomplete_labels(ac, recursive = false, inception = false, exclude = Set.new(), include = nil, &block)
        define_autocomplete_object('label', ac, recursive, inception, exclude, include, &block)
    end
    
    def define_autocomplete_issues(ac, recursive = false, inception = false, exclude = Set.new(), include = nil, &block)
        define_autocomplete_object('issue', ac, recursive, inception, exclude, include, &block)
    end
    
    def define_autocomplete_keywords(ac, recursive = false, inception = false, exclude = Set.new(), &block)
        (Set.new(all_issue_ids(recursive)) | Set.new(all_category_ids(recursive))).each do |id|
            object = load_object(id)
            object[:slug_pieces].each do |p|
                next if exclude.include?(p)
                ac.option(p, nil, inception, &block)
            end
        end
    end
    
    def cmul(c, f)
        return nil if c.nil?
        sprintf('#%02x%02x%02x', *((0..3).map { |i| (c[i * 2 + 1, 2].to_i(16).to_f * f).to_i }))
    end
    
    def warning(&block)
        STDERR.puts Paint['-' * 75, :red]
        io = StringIO.new
        yield(io)
        STDERR.puts Paint[io.string.strip, :red]
        STDERR.puts Paint['-' * 75, :red]
        STDERR.puts
    end

    def error(message)
        STDERR.puts "Error: #{message}"
        exit(1)
    end

    def assert_not_world_readable(path)
        if File.stat(path).world_readable?
            warning do |io|
                io.puts "WARNING: #{path} is world readable."
                io.puts "You should fix this with something like:"
                io.puts "$ chmod 600 #{path}"
            end
        end
    end

    def assert_ignored_by_git(path)
        `git check-ignore -q "#{path}"`
        unless $? == 0
            warning do |io|
                io.puts "WARNING: #{path} is not ignored by Git."
                io.puts "You should fix this with something like:"
                relative_path = Pathname.new(path).relative_path_from(Pathname.new(File::join(@project_root, '..'))).to_s
                gitignore_path = Pathname.new(File.join(@project_root, '..', '.gitignore')).relative_path_from(Pathname.new($pwd)).to_s
                io.puts "$ echo '#{relative_path}' >> #{gitignore_path}"
                io.puts "$ git add #{gitignore_path} && git commit -m '.gitignore update for gl'"
            end
        end
    end

    def setup
        @project_root = Dir::pwd
        while !File::directory?(File::join(@project_root, '.git'))
            @project_root = File.expand_path('..', @project_root)
            if @project_root == '/'
                error('Not a git repository.')
            end
        end

        Dir::chdir(@project_root)

        @project_root = File::join(@project_root, '.gl')

        @hook_path = File::join(@project_root, '..', '.git', 'hooks', 'prepare-commit-msg')

        unless File::exist?(@hook_path)
            unless ARGV.first == 'init'
                STDERR.puts "Error: project not initialized. Please run 'gl init'."
                STDERR.puts "If you're just installing gl on your machine, you might want to create the following symlink:"
                STDERR.puts "$ sudo ln -s #{File::expand_path(__FILE__)} /usr/local/bin/gl"
                exit(1)
            end
        end

        @config_path = File::join(@project_root, 'config.yaml')
        if File::exist?(@config_path)
            @config = YAML::load(File::read(@config_path))
            @project_uri = @config['project_uri']
        else
            git_remote = `git remote get-url origin`.strip
            remote_uri = git_remote.sub('git@', 'https://').sub(':', '/').sub('.git', '')
            @project_uri_path = File::join(@project_root, 'project_uri')
            STDERR.puts "Error: no project configuration defined (#{@config_path} not found)."
            STDERR.puts "This only has to be done once and you should only see this if you're the project maintainer."
            STDERR.puts "Go to the project's GitLab page and enter the URL shown in your browser's address bar."
            STDERR.puts
            STDERR.print "Project URL [#{remote_uri}] "
            uri = STDIN.readline.strip
            if uri.empty?
                uri = remote_uri
            end
            STDERR.puts
            u = URI::parse(uri)
            @project_uri = "#{u.scheme}://#{u.host}/api/v4/projects/#{u.path.split('/').select { |x| !x.empty? }.join('%2f')}"
            STDERR.puts "I've derived the following project URI from what you've just entered:"
            STDERR.puts @project_uri
            STDERR.puts
            STDERR.puts "If you need to correct this, please edit .gl/config.yaml - this is where the project URI is stored, along with other settings"
            STDERR.puts "Please add and commit .gl/config.yaml so that other developers won't have to repeat this step:"
            STDERR.puts
            STDERR.puts "$ git add #{@config_path}"
            STDERR.puts "$ git commit -m 'added gl configuration'"

            FileUtils::mkpath(File::dirname(@config_path))

            @config = {'project_uri' => @project_uri, 'max_commit_message_header_length' => nil}

            File::open(@config_path, 'w') do |f|
                f.puts(@config.to_yaml)
            end
        end

        @private_token_path_repository = File::join(@project_root, 'private_token')
        @private_token_path_user = File::join(Dir.home, '.gl_private_token')
        if File.exist?(@private_token_path_repository)
            assert_not_world_readable(@private_token_path_repository)
            assert_ignored_by_git(@private_token_path_repository)
            @token = File::read(@private_token_path_repository).strip
        else
            if File.exist?(@private_token_path_user)
                assert_not_world_readable(@private_token_path_user)
                @token = File::read(@private_token_path_user).strip
            else
                STDERR.puts "Error: no private token stored for GitLab API access."
                STDERR.puts "Please log into GitLab and create a Personal Access Token:"
                u = URI::parse(@project_uri)
                STDERR.puts
                STDERR.puts "#{u.scheme}://#{u.host}/profile/personal_access_tokens"
                STDERR.puts
                STDERR.puts "Make sure you check the 'api' checkbox!"
                STDERR.puts "When you're done, paste the token here:"
                STDERR.puts
                STDERR.print "Token: "
                @token = STDIN.readline.strip
                FileUtils::mkpath(File::dirname(@private_token_path_repository))
                File::open(@private_token_path_repository, 'w') do |f|
                    f.write(@token)
                end
                # set file permissions (it's a private token and as such it should be private)
                File.chmod(0600, @private_token_path_repository)
                assert_ignored_by_git(@private_token_path_repository)
            end
        end
        @state_path = File::join(@project_root, 'state.yaml')
        assert_ignored_by_git(@state_path)

        update_if_necessary
        data = YAML::load(File::read(@state_path))
        @issues = data[:issues]
        @labels = data[:labels]
        @tokens = {}
        @tokens_by_type = {
            :label => Set.new(),
            :issue => Set.new(),
            :open_issue => Set.new(),
            :closed_issue => Set.new()
        }
        # extract tokens from issues and labels (for auto-completion)
        @issues.values.each do |issue|
            slug_parts = issue['title'].parameterize.split('-')
            if issue['assignee']
                slug_parts += issue['assignee']['name'].parameterize.split('-')
            end
            slug_parts << issue['iid'].to_s
            slug_parts.each do |token|
                @tokens[token] ||= Set.new()
                @tokens[token] << issue['iid']
                @tokens_by_type[:issue] << token
                if issue['status'] == 'opened'
                    @tokens_by_type[:open_issue] << token
                elsif issue['status'] == 'closed'
                    @tokens_by_type[:closed_issue] << token
                end
            end
        end
        @labels.values.each do |label|
            slug_parts = label['name'].parameterize.split('-')
            slug_parts.each do |token|
                @tokens[token] ||= Set.new()
                @tokens[token] << label['name']
                @tokens_by_type[:label] << token
            end
        end
    end

    def current_issue()
        id = `git branch`.split("\n").select do |x|
            x.strip[0, 1] == '*'
        end.first.sub('*', '').strip.split('-').first
        if id =~ /^\d+$/
            id.to_i
        else
            nil
        end
    end

    def init()
        FileUtils::mkpath(File::dirname(@hook_path))
        File::open(@hook_path, 'w') do |f|
            f.write DATA.read
        end
        system("chmod +x \'#{@hook_path}\'")
        STDERR.puts "Successfully installed Git prepare-commit-msg hook."
    end

    def curl_gitlab(url)
        page = 1
        data = nil
        loop do
            header_path = Dir::Tmpname.create('gl-curl-response-headers') {}
            command = "curl -D \"#{header_path}\" -sS --header 'PRIVATE-TOKEN: #{@token}' '#{@project_uri}/#{url}/?per_page=100&page=#{page}'"
            stdin, stdout, stderr, thread = Open3.popen3(command)
            stdin.close
            exit_code = thread.value.exitstatus
            if exit_code == 0
                body = stdout.read
                new_data = JSON::parse(body)
                if data.nil?
                    data = new_data
                else
                    data += new_data
                end
            else
                STDERR.print "\r"
                STDERR.puts stderr.read
                exit(1)
            end
            stdout.close
            stderr.close
            headers = {}
            File::read(header_path).split("\n").each do |x|
                colon_index = x.index(':')
                next unless colon_index
                key = x[0, colon_index].strip
                value = x[colon_index + 1, x.size].strip
                headers[key] = value
            end
            if headers['X-Page'] && headers['X-Page'].to_i < headers['X-Total-Pages'].to_i
                page += 1
            else
                break
            end
        end
        data
    end

    def update()
        thread = Thread.new do
            loop do
                ['|', '/', '-', '\\'].each do |c|
                    STDERR.print "\r#{c}"
                    sleep 0.1
                end
            end
        end
        thread.run

        t1 = Thread.new do
            @issues = {}
            curl_gitlab('issues').each do |entry|
                @issues[entry['iid']] = entry
            end
        end
        t1.run
        t2 = Thread.new do
            @labels = {}
            curl_gitlab('labels').each do |entry|
                @labels[entry['name']] = entry
            end
        end
        t2.run
        
        t1.join
        t2.join
        
        issues_by_status = {}
        @issues.values.each do |issue|
            issues_by_status[issue['state']] ||= 0
            issues_by_status[issue['state']] += 1
        end

        thread.kill
        STDERR.print "\r"

        STDERR.puts "Fetched #{@issues.size} issues (#{issues_by_status.keys.sort.reverse.map { |x| "#{issues_by_status[x]} #{x}" }.join(', ')}) and #{@labels.size} labels."
        File::open(@state_path, 'w') do |f|
            data = {}
            data[:issues] = @issues
            data[:labels] = @labels
            f.write data.to_yaml
        end

        # TODO: update branch names
    end

    def update_if_necessary
        update unless File::exist?(@state_path)
    end

    def unicode_strike_through(s)
        result = ''
        s.each_char do |c|
            result += c
            result += "\u0336"
        end
        return result
    end
    
    def list(args = [])
        show_states = ['opened']
        if args.include?('--all')
            show_states = ['opened', 'closed']
        elsif args.include?('--closed')
            show_states = ['closed']
        end
        show_labels = Set.new(args.select { |x| x[0] != '-' })
        id_width = @issues.keys.max.to_s.size
#         puts Paint[' Bug ' + ' ' * 30, '#ef2929', '#721f1f']
        @issues.keys.sort.each do |id|
            issue = @issues[id]
            if show_states.include?(issue['state'])
                unless show_labels.empty?
                    next if (Set.new(issue['labels'].map { |x| x.parameterize }) & show_labels).empty?
                end
                color = nil
                bgcolor = nil
                id_s = "[##{id}]"
                if issue['state'] == 'closed'
                    id_s = unicode_strike_through(id_s)
                    color = '#666'
                    bgcolor = '#222'
                end
                print Paint["#{' ' * (id_width - id.to_s.size)}#{id_s} #{issue['title']}", color, bgcolor]
                unless issue['labels'].empty?
                    s = issue['labels'].sort.map do |label|
                        color = nil
                        if @labels.include?(label)
                            color = @labels[label]['color']
                        end
                        Paint[label, color, bgcolor]
                    end
                    print Paint[' (', nil, bgcolor]
                    print s.join(Paint[' / ', nil, bgcolor])
                    print Paint[')', nil, bgcolor]
#                     print Paint["(#{issue['labels'].sort.join(', ')})", :blue]
                end
                puts
            end
        end
    end

    def show(id)
        id = current_issue if id.nil?
        if id.nil?
            STDERR.puts "Usage: gl show <issue id>"
            exit(1)
        end
        update_if_necessary
        if @issues.include?(id)
            issue = @issues[id]
            l = "[##{id}] #{issue['title']}"
            puts '-' * 75
            puts l
            puts '-' * 75
            puts "Labels:   #{issue['labels'].empty? ? '(none)' : issue['labels'].join(', ')}"
            puts "State:    #{issue['state']}"
            puts "Created:  #{issue['created_at'][0, 10]}"
            if issue['assignee']
                puts "Assigned: #{issue['assignee']['name']}"
            end
            if issue['due_date']
                duration = (DateTime.parse(issue['due_date']) - DateTime.now).to_f.ceil
                if duration == 0
                    duration = "today"
                elsif duration == 1
                    duration = "tomorrow"
                elsif duration < 7
                    duration = "#{duration} days from now"
                else
                    duration = "#{duration / 7} weeks from now"
                end
                puts "Due date: #{issue['due_date'][0, 10]} (#{duration})"
            end
#             puts "Updated:  #{issue['updated_at'][0, 10]}"
            puts "URL:      #{issue['web_url']}"
            puts
            puts issue['description']
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end

    def start(id)
        if id.nil?
            STDERR.puts "Usage: gl start <issue id>"
            exit(1)
        end
        update_if_necessary
        if @issues.include?(id)
            branch_name = "#{id}-#{@issues[id]['title'].parameterize}"
            system("git branch #{branch_name} 2> /dev/null")
            system("git checkout #{branch_name}")
            if $?.success?
                merged_branches = `git branch --merged #{branch_name}`.split.map do |x|
                    x.strip
                end
                if merged_branches.include?('master')
                    puts "Branch is up-to-date with master."
                else
                    puts "Branch is not up-to-date with master, please run:"
                    puts "$ git merge master"
                end
            end
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end

    def commit(id, args)
        id = current_issue if id.nil?
        if id.nil?
            STDERR.puts "Usage: gl commit <issue id> [further options passed to git]"
            exit(1)
        end
        update_if_necessary
        if @issues.include?(id)
            system("GL_COMMIT_USING_ISSUE=#{id} git commit #{(args || []).join(' ')}")
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end

    def commit_message()
        update_if_necessary
        id = nil
        if ENV.include?('GL_COMMIT_USING_ISSUE')
            id ||= ENV['GL_COMMIT_USING_ISSUE'].to_i
        end
        id ||= current_issue
        if id
            if @issues.include?(id)
                line = "[##{id}] #{@issues[id]['title']}".strip
                max_length = @config['max_commit_message_header_length']
                if max_length && line.size > max_length - 3
                    line = line[0, max_length - 3] + '...'
                end
                puts line
            else
                puts "# Error: no issue found with id #{id}."
            end
        else
            puts "# You're not in a topic branch. :-("
        end
    end

    def collect_labels()
        if @all_labels.nil?
            @all_labels = Set.new()
            @issues.values.each do |issue|
                @all_labels |= Set.new(issue['labels'])
            end
        end
        @all_labels
    end

    def labels()
        collect_labels().sort.each do |label|
            puts label
        end
    end

    def run
        args = ARGV
        command = args.shift
        case command
        when 'init'
            init
        when 'update'
            update
        when 'list'
            run_pager
            list(args)
        when 'start'
            start(args[1].nil? ? nil : args[1].to_i)
        when 'commit'
            commit(args[1].nil? ? nil : args[1].to_i, args[2, args.size - 2])
        when 'show'
            show(args[1].nil? ? nil : args[1].to_i)
        when 'commit-message'
            commit_message
        when 'labels'
            labels
        else
            puts 'Usage: gl <init|update|list|start|commit|show|labels>'
            puts '  init           - set up git hook'
            puts '  update         - fetch issues from GitLab server'
            puts '  list [<label>] - list all open issues (with label if specified)'
            puts '  start <id>     - start a topic branch for the given issue'
            puts '  commit <id>    - commit for an issue from any branch'
            puts '  show <id>      - show issue'
            puts '  labels         - show labels'
        end
    end
    
    def show_help(args)
        items = HELP_TEXT.strip.split(/^__(.+)$/)
        items.shift
        texts = {}
        i = 0
        while (i + 1) < items.size
            texts[items[i]] = items[i + 1].strip
            i += 2
        end
        key = args.join('/')
        if texts.include?(key)
            puts texts[key]
        else
            puts texts['default']
        end
    end
    HELP_TEXT = <<END
__default
gl - GitLab issue tracking intertwined with Git

Usage: gl <command> [<args>]

Available issue-related commands:
new           Create a new issue
list          List issues
show          Show issue information
edit          Edit an issue
start         Start working on an issue
close         Close an issue
reopen        Reopen a previously closed issue
locate        Find commits and corresponding branches for an issue
commit        Commit using an issue, regardless of the current branch

Miscellaneous commands:
update        Update issues from GitLab server
labels        Show available labels
search        Search for categories or issues
help          Show usage information

See 'gl help <command>' for more information on a specific command.
gl supports tab completion pretty well - try to specify labels or
issue IDs via keywords, they will be auto-completed.

__new
Usage: gl new [<labels>] [<title>]

Create a new issue. Optionally, labels can be specified which should be
assigned to the issue. You may specify the issue title on the command line.

__list
Usage: gl list [--closed] [--all] [<labels>]

List issues. Optionally, labels can be specified for filtering.
By default, this lists open issues only. Specify --closed to list closed issues
only or --all to list open and closed issues.

__show
Usage: gl show [<issue>]

Show issue information. If no issue is specified, show the current issue as
denoted by the branch name.

__edit
Usage: gl edit [<issue>]

Edit an issue. If no issue is specified, show the current issue as denoted by 
the branch name.

__start
Usage: gl start <issue>

Start working on an issue. gl will create a topic branch for the specified issue 
using the same naming convention as GitLab. The branch name starts with the issue 
ID followed by a dash, and through this pattern the git hooks set up by gl are 
able to determine which issue all commits made in this branch should be connected to.

__close
Usage: gl close <issue>
Close an issue.

__reopen
Usage: gl reopen <issue>
Reopen a previously closed issue.

__commit
Usage: gl commit <issue> [<args> ...]

Commit using the specified issue, regardless of the current branch. Any extra arguments
are passed on to 'git commit'.

__update
Usage: gl update
Fetch changes from GitLab server.

__search
Usage: gl search <keywords>
Search for issues.
END
end

$pwd = Dir.pwd
begin
    script = GitLabIssuesConnectedToGit.new
#     script.run
ensure
    Dir.chdir($pwd)
end

__END__
#!/usr/bin/env ruby

template = File::read(ARGV.first)
unless template.index('Merge branch') == 0
    message = `gl commit-message`

    File::open(ARGV.first, 'w') do |f|
        f.puts message
        f.write(template)
    end
end
