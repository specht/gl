#!/usr/bin/env ruby

require 'fileutils'
require 'json'
require 'yaml'
require 'uri'
require 'active_support/all'
require 'open3'
require 'tempfile'

class GitLabIssuesConnectedToGit
    def initialize()
        if ENV['COMP_LINE']
            parts = ENV['COMP_LINE'].split(' ')
            parts << '' if ENV['COMP_LINE'][-1] == ' '
            parts.shift()
            if parts.size == 1
                ['init', 'update', 'list', 'show', 'start', 'commit'].each do |w|
                    if w.index(parts.last) == 0
                        puts w
                    end
                end
            elsif ['start', 'commit', 'show'].include?(parts.first)
                allow_closed = true
                allow_closed = false if ['start', 'commit'].include?(parts.first)
                setup(false)
                update() unless File::exists?(@issues_path)
                @issues.each_pair do |id, issue|
                    next if (!allow_closed) && @issues[id]['state'] != 'opened'
                    slug = issue['title'].parameterize
                    branch_name = "#{id}-#{slug}"
                    search_terms = parts[1, parts.size - 1]
                    left_over_search_terms = search_terms.reject do |term|
                        term = term.downcase
                        slug.split('-').any? do |x|
                            x.downcase[0, term.size] == term
                        end || slug[0, term.size] == term
                    end
                    if left_over_search_terms.empty?
                        puts branch_name
                    else
                        if branch_name.index(search_terms.first.downcase) == 0
                            if branch_name != search_terms.first
                                puts branch_name
                            end
                        end
                    end
                end
            end
            exit(0)
        end
        
        setup(true)
    end
    
    def setup(interactive)
        @project_root = Dir::pwd
        while !File::directory?(File::join(@project_root, '.git'))
            @project_root = File.expand_path('..', @project_root)
            if @project_root == '/'
                STDERR.puts "Error: Not a git repository."
                exit(1)
            end
        end
        
        Dir::chdir(@project_root)

        @project_root = File::join(@project_root, '.gl')

        @project_uri_path = File::join(@project_root, 'project_uri')
        @private_token_path = File::join(@project_root, 'private_token')
        @issues_path = File::join(@project_root, 'issues.yaml')
        @hook_path = File::join(@project_root, '..', '.git', 'hooks', 'prepare-commit-msg')
        
        unless File::exists?(@hook_path)
            unless ARGV.first == 'init'
                STDERR.puts "Error: project not initialized. Please run 'gl init'."
                STDERR.puts "If you're just installing gl on your machine, you might want to create the following symlink:"
                STDERR.puts "$ sudo ln -s #{File::expand_path(__FILE__)} /usr/local/bin/gl"
                exit(1)
            end
        end

        if File::exists?(@project_uri_path)
            @project_uri = File::read(@project_uri_path).strip
        else
            STDERR.puts "Error: no project URI defined."
            STDERR.puts "This only has to be done once and you should only see this if you're the project maintainer."
            STDERR.puts "Go to the project page and enter the URL shown in your browser's address bar."
            STDERR.puts
            STDERR.print "Project URL: "
            uri = STDIN.readline.strip
            STDERR.puts
            u = URI::parse(uri)
            @project_uri = "#{u.scheme}://#{u.host}/api/v4/projects/#{u.path.split('/').select { |x| !x.empty? }.join('%2f')}"
            STDERR.puts "I've derived the following project URI from what you've just entered:"
            STDERR.puts @project_uri
            STDERR.puts
            STDERR.puts "If you need to correct this, please edit .gl/project_uri - this is where the project URI is stored."
            STDERR.puts "Please add and commit .gl/project_uri so that other developers won't have to repeat this step:"
            STDERR.puts
            STDERR.puts "$ git add .gl/project_uri"
            STDERR.puts "$ git commit -m 'added .gl/project_uri'"
            
            FileUtils::mkpath(File::dirname(@project_uri_path))
            File::open(@project_uri_path, 'w') do |f|
                f.write(@project_uri)
            end
        end
        if File::exists?(@private_token_path)
            @token = File::read(@private_token_path).strip
        else
            STDERR.puts "Error: no private token stored for GitLab API access."
            STDERR.puts "Please log into GitLab and create a Personal Access Token:"
            u = URI::parse(@project_uri)
            STDERR.puts
            STDERR.puts "#{u.scheme}://#{u.host}/profile/personal_access_tokens"
            STDERR.puts
            STDERR.puts "Make sure you check the 'api' checkbox!"
            STDERR.puts "When you're done, paste the token here:"
            STDERR.puts
            STDERR.print "Token: "
            @token = STDIN.readline.strip
            FileUtils::mkpath(File::dirname(@private_token_path))
            File::open(@private_token_path, 'w') do |f|
                f.write(@token)
            end
        end
        update() unless File::exists?(@issues_path)
        @issues = YAML::load(File::read(@issues_path))
    end
    
    def current_issue()
        id = `git branch`.split("\n").select do |x|
            x.strip[0, 1] == '*'
        end.first.sub('*', '').strip.split('-').first
        if id =~ /^\d+$/
            id.to_i
        else
            nil
        end
    end
    
    def init()
        FileUtils::mkpath(File::dirname(@hook_path))
        File::open(@hook_path, 'w') do |f|
            f.write <<~eos
                #!/usr/bin/env ruby
            
                template = File::read(ARGV.first)
                unless  template.index('Merge branch') == 0
                    message = `gl commit-message`

                    File::open(ARGV.first, 'w') do |f|
                        f.puts message
                        f.write(template)
                    end
                end
            eos
        end
        system("chmod +x \'#{@hook_path}\'")
        STDERR.puts "Successfully installed Git prepare-commit-msg hook."
    end
    
    def curl_gitlab(url)
        page = 1
        data = nil
        loop do
            header_path = Dir::Tmpname.create('gl-curl-response-headers') {}
            command = "curl -D \"#{header_path}\" -sS --header 'PRIVATE-TOKEN: #{@token}' #{@project_uri}/#{url}/?page=#{page}"
            stdin, stdout, stderr, thread = Open3::popen3(command)
            stdin.close
            exit_code = thread.value
            if exit_code == 0
                body = stdout.read
                new_data = JSON::parse(body)
                if data.nil?
                    data = new_data
                else
                    data += new_data
                end
            else
                STDERR.print "\r"
                STDERR.puts stderr.read
                exit(1)
            end
            stdout.close
            stderr.close
            headers = {}
            File::read(header_path).split("\n").each do |x|
                colon_index = x.index(':')
                next unless colon_index
                key = x[0, colon_index].strip
                value = x[colon_index + 1, x.size].strip
                headers[key] = value
            end
            if headers['X-Page']
                if headers['X-Page'].to_i < headers['X-Total-Pages'].to_i
                    page += 1
                else
                    break
                end
            else
                break
            end
        end
        data
    end
    
    def update()
        thread = Thread.new do
            while true do
                ['|', '/', '-', '\\'].each do |c|
                    STDERR.print "\r#{c}"
                    sleep 0.1
                end
            end
        end
        thread.run
        
        issues = {}
        curl_gitlab('issues').each do |entry|
            issues[entry['iid']] = entry
        end
        issues_by_status = {}
        issues.values.each do |issue|
            issues_by_status[issue['state']] ||= 0
            issues_by_status[issue['state']] += 1
        end
        
        thread.kill
        STDERR.print "\r"

        STDERR.puts "Fetched #{issues.size} issues (#{issues_by_status.keys.sort.reverse.map { |x| "#{issues_by_status[x]} #{x}" }.join(', ')})."
        File::open(@issues_path, 'w') do |f|
            f.write issues.to_yaml
        end
        @issues = issues
        
        # TODO: update branch names
    end
    
    def list()
        id_width = @issues.keys.max.to_s.size
        @issues.keys.sort.each do |id|
            if @issues[id]['state'] == 'opened'
                print "[##{id}]#{' ' * (id_width - id.to_s.size)} #{@issues[id]['title']}"
                puts
            end
        end
    end
    
    def show(id)
        id = current_issue if id.nil?
        if id.nil?
            STDERR.puts "Usage: gl show <issue id>"
            exit(1)
        end
        update() unless File::exists?(@issues_path)
        if @issues.include?(id)
            issue = @issues[id]
            l = "[##{id}] #{issue['title']}"
            puts '-' * 75
            puts l
            puts '-' * 75
            puts "Labels:   #{issue['labels'].empty? ? '(none)' : issue['labels'].join(', ')}"
            puts "State:    #{issue['state']}"
            puts "Created:  #{issue['created_at'][0, 10]}"
            if issue['assignee']
                puts "Assigned: #{issue['assignee']['name']}"
            end
            if issue['due_date']
                duration = (DateTime.parse(issue['due_date']) - DateTime.now).to_i
                if duration < 7
                    duration = "#{duration} days"
                else
                    duration = "#{duration / 7} weeks"
                end
                puts "Due date: #{issue['due_date'][0, 10]} (#{duration} from now)"
            end
#             puts "Updated:  #{issue['updated_at'][0, 10]}"
            puts "URL:      #{issue['web_url']}"
            puts
            puts issue['description']
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end
    
    def start(id)
        if id.nil?
            STDERR.puts "Usage: gl start <issue id>"
            exit(1)
        end
        update() unless File::exists?(@issues_path)
        if @issues.include?(id)
            branch_name = "#{id}-#{@issues[id]['title'].parameterize}"
            system("git branch #{branch_name} 2> /dev/null")
            system("git checkout #{branch_name}")
            merged_branches = `git branch --merged #{branch_name}`.split.map do |x|
                x.strip
            end
            if merged_branches.include?('master')
                puts "Branch is up-to-date with master."
            else
                puts "Branch is not up-to-date with master, please run:"
                puts "$ git merge master"
            end
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end

    def commit(id, args)
        id = current_issue if id.nil?
        if id.nil?
            STDERR.puts "Usage: gl commit <issue id> [further options passed to git]"
            exit(1)
        end
        update() unless File::exists?(@issues_path)
        if @issues.include?(id)
            system("GL_COMMIT_USING_ISSUE=#{id} git commit #{args.join(' ')}")
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end

    def commit_message()
        update() unless File::exists?(@issues_path)
        id = nil
        if ENV.include?('GL_COMMIT_USING_ISSUE')
            id ||= ENV['GL_COMMIT_USING_ISSUE'].to_i
        end
        id ||= current_issue
        if id 
            if @issues.include?(id)
                puts "[##{id}] #{@issues[id]['title']}"
            else
                puts "# Error: no issue found with id #{id}."
            end
        else
            puts "# You're not in a topic branch. :-("
        end
    end
            
    def run()
        args = ARGV
        command = args.first
        case command
        when 'init'
            init()
        when 'update'
            update()
        when 'list'
            list()
        when 'start'
            start(args[1].nil? ? nil : args[1].to_i)
        when 'commit'
            commit(args[1].nil? ? nil : args[1].to_i, args[2, args.size - 2])
        when 'show'
            show(args[1].nil? ? nil : args[1].to_i)
        when 'commit-message'
            commit_message()
        else
            puts "Usage: gl <init|update|list|start|commit>"
            puts "  init        - set up git hook"
            puts "  update      - fetch issues from GitLab server"
            puts "  list        - list all open issues"
            puts "  start <id>  - start a topic branch for the given issue"
            puts "  commit <id> - commit for an issue from any branch"
            puts "  show <id>   - show issue"
        end
    end
end

pwd = Dir::pwd
begin
    script = GitLabIssuesConnectedToGit.new
    script.run
ensure
    Dir::chdir(pwd)
end
