#!/usr/bin/env ruby

require 'json'
require 'yaml'
require 'paint'

class GitLabIssuesConnectedToGit
    def initialize()
        if ENV['COMP_LINE']
            parts = ENV['COMP_LINE'].split(' ')
            parts << '' if ENV['COMP_LINE'][-1] == ' '
            parts.shift()
            if parts.size == 1
                ['init', 'update', 'list', 'show', 'branch'].each do |w|
                    if w.index(parts.last) == 0
                        puts w
                    end
                end
            end
            exit(0)
        end

        @project_root = Dir::pwd
        while !File::directory?(File::join(@project_root, '.git'))
            @project_root = File.expand_path('..', @project_root)
            if @project_root == '/'
                STDERR.puts "Error: Not a git repository."
                exit(1)
            end
        end
        
        Dir::chdir(@project_root)

        @project_root = File::join(@project_root, '.gl')

        @project_uri_path = File::join(@project_root, 'project_uri')
        @private_token_path = File::join(@project_root, 'private_token')
        @issues_path = File::join(@project_root, 'issues.yaml')

        @project_uri = File::read(@project_uri_path).strip
        @token = File::read(@private_token_path).strip
    end
    
    def init()
        hook_path = File::join(@project_root, '..', '.git', 'hooks', 'prepare-commit-msg')
        File::open(hook_path, 'w') do |f|
            f.write <<~eos
                #!/usr/bin/env ruby

                template = File::read(ARGV.first)
                unless  template.index('Merge branch') == 0
                    message = `gl commit-message`

                    File::open(ARGV.first, 'w') do |f|
                        f.puts message
                        f.write(template)
                    end
                end
            eos
        end
        system("chmod +x \'#{hook_path}\'")
        STDERR.puts "Successfully installed Git prepare-commit-msg hook."
    end
    
    def update()
        command = "curl -s --header 'PRIVATE-TOKEN: #{@token}' #{@project_uri}/issues"
        thread = Thread.new do
            while true do
                ['|', '/', '-', '\\'].each do |c|
                    STDERR.print "\r#{c}"
                    sleep 0.1
                end
            end
        end
        thread.run
        data = JSON.parse(`#{command}`)
        issues = {}
        data.each do |entry|
            issues[entry['iid']] = {
                :entry => entry,
                :slug => entry['title'].downcase.gsub(/[^a-zA-Z0-9]+/, ' ').strip.gsub(' ', '-')
            }
        end
        thread.kill
        STDERR.puts "\rFetched #{issues.size} issues."
        File::open(@issues_path, 'w') do |f|
            f.write issues.to_yaml
        end
        
        # TODO: update branch names
        
        branches = `git branch`
    end
    
    def list()
        update() unless File::exists?(@issues_path)
        issues = YAML::load(File::read(@issues_path))
        id_width = issues.keys.max.to_s.size
        issues.keys.sort.each do |id|
            if issues[id][:entry]['state'] == 'opened'
                print Paint[sprintf("%-#{id_width}s", "[#{id}]"), :green]
                print ' '
                print sprintf('%s', issues[id][:entry]['title'])
                puts
            end
        end
    end
    
    def show(id)
        if id.nil?
            STDERR.puts "Usage: gl show <issue id>"
            exit(1)
        end
        update() unless File::exists?(@issues_path)
        issues = YAML::load(File::read(@issues_path))
        if issues.include?(id)
            issue = issues[id][:entry]
            l = "[#{id}] #{issue['title']}"
            puts '-' * 75
            puts l
            puts '-' * 75
            puts "Labels:  #{issue['labels'].join(', ')}"
            puts "State:   #{issue['state']}"
            puts "Created: #{issue['created_at'][0, 10]}"
            puts "Updated: #{issue['updated_at'][0, 10]}"
            puts "URL:     #{issue['web_url']}"
            puts
            puts issue['description']
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end
    
    def branch(id)
        if id.nil?
            STDERR.puts "Usage: gl branch <issue id>"
            exit(1)
        end
        update() unless File::exists?(@issues_path)
        issues = YAML::load(File::read(@issues_path))
        if issues.include?(id)
            branch_name = "#{id}-#{issues[id][:slug]}"
            system("git branch #{branch_name} 2> /dev/null")
            system("git checkout #{branch_name} 2> /dev/null")
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end

    def commit_message()
        update() unless File::exists?(@issues_path)
        id = `git branch`.split("\n").select do |x|
            x.strip[0, 1] == '*'
        end.first.sub('*', '').strip.split('-').first.to_i
        issues = YAML::load(File::read(@issues_path))
        if issues.include?(id)
            puts "[#{id}] #{issues[id][:entry]['title']}"
        else
            STDERR.puts "Error: no issue found with id #{id}."
        end
    end
            
    def run()
        args = ARGV
        command = args.first
        case command
        when 'init'
            init()
        when 'update'
            update()
        when 'list'
            list()
        when 'branch'
            branch(args[1].nil? ? nil : args[1].to_i)
        when 'show'
            show(args[1].nil? ? nil : args[1].to_i)
        when 'commit-message'
            commit_message()
        else
            puts "Usage: gl <init|update|list|branch>"
        end
    end
end

pwd = Dir::pwd
begin
    script = GitLabIssuesConnectedToGit.new
    script.run
ensure
    Dir::chdir(pwd)
end
